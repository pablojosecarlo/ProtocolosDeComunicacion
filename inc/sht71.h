/*
 *  SHT71.h
 *
 *  Created on: Dec 2, 2019
 *      Author: Pablo JC Alonso Castillo
 */

#ifndef __DEMO_SHT71_H
#define __DEMO_SHT71_H

#include "sapi.h"

/*
GENERALIDADES DEL SHT71

01) EL DATO QUE SE RECIBE EN EL PIC (IE. EL QUE ENVIA EL SHT71) CAMBIA EN EL FLANCO (-) DEL CLOCK

02) EL DATO QUE SE ENVIA DE LA CIAA AL SHT71 ES TOMADO POR EL SHT71 EN EL FLANCO (+) DEL CLOCK
		LA LINEA DE DATOS DEBEN PERMANECER ESTABLE MIENTRAS EL CLOCK ESTÁ EN ALTO
		1°) DATA_IN     DATO LEIDO (EN EL PIC)
		2°) DATA_OUT    DATO A GUARDAR (EN EL SHT171)

03) COMO LOS BYTES (A LEER O ESCRIBIR) SE ENVIAN EN SERIE, PARA NO ARRUINAR LOS ORIGINALES, SE PONEN EN BUFFERES TRANSITORIOS
		1°) RX_BUFFER   BUFFER DE DATA IN
		2°) TX_BUFFER   BUFFER DE DATA OUT

04) EL "CONTROL BYTE" PARA LA IDENTIFICACIÓN, CHIP SELECT Y R/W DE LA MEMORIA TIENE:
		[(3 ADDRESS BITS = 000 SIEMPRE) + (5 BITS DE COMANDO = XXXXX)] = 000.XXXXX

		COMANDOS: (NÓTESE QUE LOS READ TERMINAN EN 1 AUNQUE EL DATASHEET NO DIGA NADA)

		01°) 0000X = RESERVADO					000.0000X = 0,1
		02°) 00011 = READ (MESURE) TEMPERATURE	000.00011 = 3
		03°) 00101 = READ (MESURE) HUMIDITY		000.00101 = 5
		04°) 00111 = READ STATUS REGISTER		000.00111 = 7
		05°) 00110 = WRITE STATUS REGISTER		000.00110 = 6
		06°) 0101X <-> 1110X = RESERVADO		000.01010 = 10 <-> 000.11101 = 29
		07°) 11110 = SOFT RESET					000.11110 = 30

		COMAMDOS MISTERIOSOS (QUE NO SERVIRIAN PARA NADA)
		08°) 00010 = ¿WRITE TEMPERATURA?		000.00100 = 2
		09°) 00100 = ¿WRITE HUMEDAD?			000.00100 = 4
		11°) 01000 = FALTA						000.01000 = 8
		12°) 01001 = FALTA						000.01001 = 9
		12°) 11111 = FALTA						000.01001 = 31
*/

//	CONSTANTES ASOCIADAS A LOS COMANDOS
#define CMD_SHT71_READ_TEMPERATURA  0b00000011	//	= 3
#define CMD_SHT71_READ_HUMEDAD 		0b00000101	//	= 5
#define CMD_SHT71_READ_STATUS_REG	0b00000111	//	= 7
#define CMD_SHT71_WRITE_STATUS_REG	0b00000110	//	= 6
#define CMD_SHT71_SOFT_RESET		0b00011110	//	= 30

//	CONSTANTES DE FLAGS ASOCIADAS AL STATUS REGISTER
#define STSREG_END_OF_BATTERY	6	//0=>VDD>2.47V, 1=>VDD<2.47V END OF BATTERY (EOB, LOW VOLTAGE DETECTOR) SE REFRESCA AL MEDIR, NO SE SETEA, SOLO SE LEE
#define STSREG_HEATER		 	2	//0=> OFF CONSUMPTION WILL INCREASE BY 8MA @ 5V.
//														APPLICATIONS:
//														1 BY COMPARING TEMPERATURE AND HUMIDITY VALUES BEFORE AND AFTER SWITCHING ON THE HEATER, PROPER FUNCTIONALITY OF BOTH SENSORS CAN BE VERIFIED.
//														2 IN HIGH RH ENVIRONMENTS HEATING THE SENSOR ELEMENT WILL AVOID CONDENSATION.
//														WARNING: THE BUILT-IN CALIBRATION IS NOT CORRECT WHILE THE SHT11 IS HEATED!
#define STSREG_NO_RELOAD_OTP	1	//0=> ON CALIBRATION RELOAD BEFORE MEASUREMENT: A VECES SE PIERDE LA CALIBRACIÓN DE
//														LA MEMORIA DE COMPARACIÓN => 0=>RECARGAR SIEMPRES ANTES DE MEDIR, PERO ESTO DEMORA 8,2 MS POR CADA MEDIDA
#define STSREG_BITS_RESOLUTION	0	//THE MEASUREMENT RESOLUTION OF 14BIT (TEMPERATURE) AND 12BIT (HUMIDITY) CAN BE REDUCED TO 12 AND 8 BIT.
//														THIS IS ESPECIALLY USEFUL IN HIGH SPEED OR EXTREME LOW POWER APPLICATIONS
//														0 => 12BIT.RH/14BIT.TEMP
//														1 => 8BIT.RH/12BIT.TEMP
//														ALL READOUT VALUES ARE MSB FIRST, TWO BYTE RIGHT JUSTIFIED. (E.G. THE 5TH SCK IS MSB FOR A 14BIT VALUE, FOR A 8BIT RESULT THE FIRST BYTE IS NOT USED).
//LOS BITS 7,5,4 Y 3 ESTÁN RESERVADOS
//
//	CONSTANTES DE ARGUMENTOS ASOCIADAS AL STATUS REGISTER
#define STSREG_F_R_8_12		0b00000001 	//HEATER=OFF
//												OPT=RELOAD
//												8BIT RH, 12BIT TEMPERATURA
#define STSREG_F_R_12_14	0b00000000 	//HEATER=OFF
//												OPT=RELOAD
//												12BIT RH, 14BIT TEMPERATURA
#define STSREG_F_N_8_12		0b00000011 	//HEATER=OFF
//												OPT=NO RELOAD
//												8BIT RH, 12BIT TEMPERATURA
#define STSREG_F_N_12_14	0b00000010 	//HEATER=OFF
//												OPT=NO RELOAD
//												12BIT RH, 14BIT TEMPERATURA
#define STSREG_N_R_8_12		0b00000101	//HEATER=ON
//												OPT=RELOAD
//												8BIT RH, 12BIT TEMPERATURA
#define STSREG_N_R_12_14	0b00000100	//HEATER=ON
//												OPT=RELOAD
//												12BIT RH, 14BIT TEMPERATURA
#define STSREG_N_N_8_12		0b00000111	//HEATER=ON
//												OPT=NO RELOAD
//												8BIT RH, 12BIT TEMPERATURA
#define STSREG_N_N_12_14	0b00000110	//HEATER=ON
//												OPT=NO RELOAD
//												12BIT RH, 14BIT TEMPERATURA

void SETUP_SHT71( void );					//SETUP QUE EN PRINCIPIO ES IGUAL AL SETUP DEL DEMO_I2C_BASICO

void START_CONDITION_SHT71( void );			//SECUENCIA DE INICIO PARA LAS OPERACIONES DE R/W EN EL SHT71
											//REEMPLAZA EL START BITE DEL I2C Y ES UNA DE LAS 3 DIFERENCIAS CON I2C
void SHT71_SOFT_RESET( void );				//RESETEA LA INTERFACE Y COLOCA EL ESTATUS REG EN VALORES POR DEFECTO (=0?)
												//(VUELVE A ARRANCAR EL MICRO, CARGAR LOS VALORES DE CORRECCIÓN ETC.)
												//HAY QUE ESPERAR 11 MS ANTES DE ENVIAR UN COMANDO

void SHT71_CONNECTION_RESET_SECUENCE(void);		//SI SE PIERDE LA COMUNICACIÓN, RESETEA LA INTERFACE SERIE PERO CONSERVA EL STATUS REGISTER
														//PERMITE (RE)INICIAR LIMPIAMENTE LAS OPERACIONES EN EL SHT71

void SHT71_WRITE_STATUS_REGISTER( uint8_t );	//WRITE A BYTE TO THE SHT71, SOLO SE PUEDE ESCRIBIR AL STATUS REGISTER
												//EL ARGUMENTO ES ALGUNO DE LAS CONSTANTES DEFINIDAS COMO STSREG_X_X_8_12 Ó STSREG_X_X_12_14

												//STATUS REGISTER PARA BAJA RESOLUCIÓN
												//	STSREG_F_R_8_12 =1 => HEATER OFF, OPT RELOAD,    8BIT RH, 12BIT TEMP.
												//	STSREG_F_N_8_12 =3 => HEATER OFF, OPT NO RELOAD, 8BIT RH, 12BIT TEMP.
												//	STSREG_N_R_8_12 =5 => HEATER ON,  OPT RELOAD,    8BIT RH, 12BIT TEMP.
												//	STSREG_N_N_8_12 =7 => HEATER ON,  OPT NO RELOAD, 8BIT RH, 12BIT TEMP.

												//STATUS REGISTER PARA ALTA RESOLUCIÓN
												//	STSREG_F_R_12_14 =0 => HEATER OFF, OPT RELOAD,    12BIT RH, 14BIT TEMP.
												//	STSREG_F_N_12_14 =2 => HEATER OFF, OPT NO RELOAD, 12BIT RH, 14BIT TEMP.
												//	STSREG_N_R_12_14 =4 => HEATER ON,  OPT RELOAD,	  12BIT RH, 14BIT TEMP.
												//	STSREG_N_N_12_14 =6 => HEATER ON,  OPT NO RELOAD, 12BIT RH, 14BIT TEMP.

uint8_t SHT71_READ_STATUS_REGISTER(void);		//LEE EL STATUS REGISTER DEL SHT71 Y LO GUARDA EN REG_STATUS_REGISTER, GUARDA EL CHECKSUM EN REG_CHECKSUM.
												//HAY ASOCIADOS 4 FLAGS:
												//	STSREG_END_OF_BATTERY =	D'6' ,0=>VDD>2.47V, 1=>VDD<2.47V END OF BATTERY (EOB, LOW VOLTAGE DETECTOR) SE REFRESCA AL MEDIR, NO SE SETEA, SOLO SE LEE
												//	STSREG_HEATER		  =	D'2' ,0=> OFF CONSUMPTION WILL INCREASE BY 8MA @ 5V. LA TEMPERATURA SE INCREMENTA 5-15 °C
												//	STSREG_NO_RELOAD_OTP  =	D'1' ,0=> SÍ CALIBRATION RELOAD BEFORE MEASUREMENT: A VECES SE PIERDE LA CALIBRACIÓN, PERO ESTO DEMORA 8,2 MS POR CADA MEDIDA
												//	STSREG_BITS_RESOLUTION= D'0' ,0 => 12BIT.RH/14BIT.TEMP	1 => 8BIT.RH/12BIT.TEMP

#define  SHT71_LOW_BATT		0b01000000			//Bateria baja
#define  SHT71_HEAT_ON		0b00000100			//Heater On
#define  SHT71_NO_RELOAD	0b00000010			//no recargar parámetros de fábrica
#define  SHT71_LOW_RES		0b00000001			//Baja resolución 8bit RH, 12bit T

uint16_t SHT71_READ_TEMPERATURA_CRUDA(void);	//LEE LA TEMPERATURA Y GUARDA EL VALOR LEIDO EN HADD_SHT71 Y LADD_SHT71, GUARDA EL CHECKSUM EN REG_CHECKSUM

uint16_t SHT71_READ_HUMEDAD_CRUDA(void);		//LEE LA HUMEDAD Y GUARDA EL VALOR LEIDO EN HADD_SHT71 Y LADD_SHT71, GUARDA EL CHECKSUM EN REG_CHECKSUM

void BIN16_A_DIGITAL5(uint8_t, uint8_t);	//TOMA DOS UINT8_T HADD + LADD Y LOS CONVIERTE EN NÚMEROS UINT8_T DEL NUM_5 -> NUM_0

void FLOAT_A_DIGITAL5(float);          		//TOMA UN UINT16_T Y LOS CONVIERTE EN NÚMEROS UINT8_T DEL NUM_5 -> NUM_0

void FLOAT_A_LCD_BLE(float);				//Toma un float con dos decimales y lo saca por el lcd y genera un arrglo para enviar al Bluetooth LE

void  SHT71_SET_STATUS(uint8_t);		//Setea la constante de status que determina como se leerá la temp y humedad

float SHT71_READ_TEMPERATURA(void);		//LEE LA TEMPERATURA Y GUARDA EL VALOR LEIDO EN HADD_SHT71 Y LADD_SHT71, GUARDA EL CHECKSUM EN REG_CHECKSUM

float SHT71_READ_HUMEDAD(void);			//LEE LA HUMEDAD Y GUARDA EL VALOR LEIDO EN HADD_SHT71 Y LADD_SHT71, GUARDA EL CHECKSUM EN REG_CHECKSUM

float SHT71_DEW_POINT(float, float);    //CALCULA EL PUNTO DE ROCIO


//Implementacion mínima del i2c para usarse en el sht71

void I2C_OUTPUT(void);

void I2C_INPUT(void);

void GET_ACK(void);

void SEND_ACK(void);   //SHT71

void NO_ACK(void);

void TEST_ACK(void);

#endif /* __DEMO_SHT71_H */
